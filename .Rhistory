lm_model <- lm(cislo~valce)
pred <- predict(lm_model)
res <- residuals(lm(cislo~valce))
res
autoplot(pred)
#-----------------------------------------------------------------------------
## ANOVA - analyza rozptylu
library(ggbio)
plot(pred)
res_num = cislo - pred
PlotQQ(res)
PlotQQ(res)
library(DescTools)
PlotQQ(res)
par(mfrow=c(1,2))
PlotQQ(res)
PlotQQ(res_num)
par(mfrow=c(1,2))
par(mfrow=c(1,1))
# Ciselny test - normalně shapiro
tapply(cislo, valce,shapiro.test)
boxtplot(cislo~valce)
boxplot(cislo~valce)
#Test shody rozptylu
# dle vysledku se voli typ ANOVy
# H0: rozptyly jsou shodne | H1: rozptyly se lisi
bartlett.test(cislo~valce)
var.test(cislo~valce)
var.test(cislo~valce)
# Využití klasické anovy
anova(aov(cislo~valce))
# Muze prijit doplnujici otazka: ktere dvojice skupin se od sebe vyznamne lisi?
TukeyHSD(aov(cislo~valce))
# Muze prijit doplnujici otazka: ktere dvojice skupin se od sebe vyznamne lisi?
TukeyHSD(aov(cislo~valce))
# Využití klasické anovy
anova(aov(cislo~valce))
# Muze prijit doplnujici otazka: ktere dvojice skupin se od sebe vyznamne lisi?
# Párové srovnání
TukeyHSD(aov(cislo~valce))
# Muze prijit doplnujici otazka: ktere dvojice skupin se od sebe vyznamne lisi?
# Párové srovnání
tukey_result <- TukeyHSD(aov(cislo~valce))
valce <- as.factor(mtcars$cyl)
# Lisi se cas, za nejz ujedou auta 1/4 mile podle poctu valcu
cislo <- mtcars$qsec
valce <- as.factor(mtcars$cyl)
#Test normality residui linearniho modelu
lm_model <- lm(cislo~valce)
pred <- predict(lm_model) # predikce hodnot
res <- residuals(lm(cislo~valce))
res
"""
A residual is the difference between a predicted value of dependent variable y with the actual value of y.
"""
res_num = cislo - pred
par(mfrow=c(1,2))
PlotQQ(res)
PlotQQ(res_num)
par(mfrow=c(1,1))
# Ciselny test - normalně shapiro
#H0: residua maji normalni rozdeleni |H1: residua NEmaji normalni rozdeleni
tapply(cislo, valce,shapiro.test) #=> residua maji normali rozdeleni - p-value > alfa
boxplot(cislo~valce)
#Test shody rozptylu
# dle vysledku se voli typ ANOVy
# H0: rozptyly jsou shodne | H1: rozptyly se lisi
bartlett.test(cislo~valce) # => p-value = 0.4554 > alfa - maji shodne rozptyly
var.test(cislo~valce) #=> jenom pro dva levely kategorické proměné
"""
Error in var.test.formula(cislo ~ valce) :
grouping factor must have exactly 2 levels
"""
# Využití klasické anovy
anova(aov(cislo~valce))
# Muze prijit doplnujici otazka: ktere dvojice skupin se od sebe vyznamne lisi?
# Párové srovnání
tukey_result <- TukeyHSD(aov(cislo~valce))
# Muze prijit doplnujici otazka: ktere dvojice skupin se od sebe vyznamne lisi?
# Párové srovnání
tukey_result <- TukeyHSD(aov(cislo~valce))
plot(tukey_result)
## Zavisi pomer os na poctu prevodu?
cislo<-mtcars$drat
kategorie<-as.factor(mtcars$gear)
# Test normality
par(mfrow=c(1,2))
tapply(cislo,kategorie,PlotQQ)
par(mfrow=c(1,1))
# Test normality
par(mfrow=c(1,1))
# Test normality
PlotQQ(res)
kategorie<-as.factor(mtcars$gear)
res <- residuals(lm(cislo~kategorie))
# Test normality
PlotQQ(res) # => spíše normální rozdělení
shapiro.test(res)
boxplot(cislo~kategorie)
# Test shody rozptylu
#H0: rozptyly se neliší | H1: rozptyly se liší
bartlett.test(cislo~kategorie)
#Hypotézy
#H0: NEzávisí pomer os a pocet převodu | H1: Závisí pomer os a pocet prevodu
kruskal.test(cislo~kategorie)
# Ktera dvojice skupin se od sebe vyznamne lisi?
DunnTest(cislo~kategorie)
setwd("D:/PSM_TEACH/PSM_Teach")
data <- Kojeni2
load("D:/PSM_TEACH/PSM_Teach/Kojeni2.RData")
data <- Kojeni2
data <- Kojeni2
prom1 <- data$vyskaM
prom1 <- data$vyskaM
MeanCI(prom1) #<- podle MeanCI nemůže, protože je mimo dolní ci
library(DescTools)
library(TeachingDemos)
data <- Kojeni2
prom1 <- data$vyskaM
MeanCI(prom1) #<- podle MeanCI nemůže, protože je mimo dolní ci
t.test(prom1, mu=164) #p-value = 4.923e-06, takže zamítám nulovou hypotézu -> nemůže!
# Velikost vzorku
n <- length(prom1)
# Průměr
mean_value <- mean(prom1)
# Standardní odchylka
sd_value <- sd(prom1)
# Hladina významnosti (např. pro 95% interval spolehlivosti)
alpha <- 0.05
# Kritická hodnota t (pro 95% interval a n-1 stupňů volnosti)
t_value <- qt(1 - alpha/2, df = n - 1) # slouží k získání kvantilu
# Chyba odhadu
error_margin <- t_value * (sd_value / sqrt(n))
# Dolní a horní mez intervalu spolehlivosti
lower_bound <- mean_value - error_margin
upper_bound <- mean_value + error_margin
# Výsledek
interval_spolehlivosti <- c(lower_bound, upper_bound)
interval_spolehlivosti
t.test(prom1, mu=168, alternative='less') # > p-value = 0.04829 -> zamitam H0, plati H1
t.test(prom1,mu=168)
t.test(prom1,mu=168)
# Jsou matky v prumeru starsi nez 23 let?
prom2 <- data$vekM
# Nejprve otestujeme normalitu
#   H0: data maji normalni rozdeleni vs. H1: data nemaji normalni rozdeleni
shapiro.test(prom2) #p-value = 0.00134 -> zamítám H0 -> nemají
PlotQQ(prom2) # -> neleží na přímce
hmot <- data$por.hmotnost
pohlavi <- data$Hoch
par(mfrow=c(1,2))
tapply(hmot,pohlavi,PlotQQ) # jde videt, že hoši mají jak kvantily, tak průměry vyšší
# Lisi se vek maminek v Praze a na venkove (vekM, Porodnice)?
vekM <- data$vekM
porodnice <- data$Porodnice
par(mfrow=c(1,2))
tapply(vekM,porodnice,PlotQQ)
# pouzijeme neparametricky test
# Testujeme
#   H0: median vekM = 23 vs. H1: median vekM > 23
wilcox.test(prom2,mu=23, alternative="greater")
#p-value = 9.807e-09 -> zamítáme H0 - střední hodnota je větší jak 23
MeanCI(prom2) #bude kolem 25
hmot <- data$por.hmotnost
pohlavi <- data$Hoch
par(mfrow=c(1,2))
tapply(hmot,pohlavi,PlotQQ) # jde videt, že hoši mají jak kvantily, tak průměry vyšší
par(mfrow=c(1,1))
#body lezi v obou pripadech priblizne na primce
tapply(hmot,pohlavi,shapiro.test)
boxplot(hmot~pohlavi,main="Porodní hmotnost X Pohlaví")
var.test(hmot~pohlavi)
# H0: por.hmotnost divek - por.hmotnost hochu = 0;  H1: por.hmotnost divek - por.hmotnost hochu <> 0
t.test(hmot~pohlavi,var.eq=T)
# H0: por.hmotnost divek - por.hmotnost hochu = 0;  H1: por.hmotnost divek - por.hmotnost hochu <> 0
t.test(hmot~pohlavi,var.eq=T)
# p-value = 0.005512 < alfa -> zamítám H0
t.test(hmot~pohlavi,mu=0,alternative='two.sided',var.eq=T) #stejné
# Lisi se vek maminek v Praze a na venkove (vekM, Porodnice)?
vekM <- data$vekM
porodnice <- data$Porodnice
par(mfrow=c(1,2))
tapply(vekM,porodnice,PlotQQ)
# Test normality
#H0: data mají normální rozdělení | H1: nemají normální rozd.
tapply(vekM,porodnice,shapiro.test)
# Shoda rozptylu F-test
#H0: mají shodné rozptyly | H1: nemají shodné rozptyly
var.test(vekM~porodnice) #=> p-value = 0.6589 > alfa - nezamítáme H0, mají shodné rozptyly
boxplot(vekM~porodnice)
# Shoda rozptylu F-test
#H0: mají shodné rozptyly | H1: nemají shodné rozptyly
var.test(vekM~porodnice) #=> p-value = 0.6589 > alfa - nezamítáme H0, mají shodné rozptyly
boxplot(vekM~porodnice)
par(mfrow=c(1,1))
# Test normality
#H0: data mají normální rozdělení | H1: nemají normální rozd.
tapply(vekM,porodnice,shapiro.test)
# Shoda rozptylu F-test
#H0: mají shodné rozptyly | H1: nemají shodné rozptyly
var.test(vekM~porodnice) #=> p-value = 0.6589 > alfa - nezamítáme H0, mají shodné rozptyly
boxplot(vekM~porodnice)
wilcox.test(vekM~porodnice)
#-----------------------------------------------------------------------------
## ANOVA - analyza rozptylu
library(ggbio)
library(DescTools)
force(mtcars)
# Lisi se cas, za nejz ujedou auta 1/4 mile podle poctu valcu
cislo <- mtcars$qsec
valce <- as.factor(mtcars$cyl)
#Test normality residui linearniho modelu
lm_model <- lm(cislo~valce)
pred <- predict(lm_model) # predikce hodnot
res <- residuals(lm(cislo~valce))
res
par(mfrow=c(1,2))
PlotQQ(res)
PlotQQ(res_num)
par(mfrow=c(1,1))
# Ciselny test - normalně shapiro
#H0: residua maji normalni rozdeleni |H1: residua NEmaji normalni rozdeleni
tapply(cislo, valce,shapiro.test) #=> residua maji normali rozdeleni - p-value > alfa
# Ciselny test - normalně shapiro
#H0: residua maji normalni rozdeleni |H1: residua NEmaji normalni rozdeleni
tapply(cislo, valce,shapiro.test) #=> residua maji normali rozdeleni - p-value > alfa
# Lisi se cas, za nejz ujedou auta 1/4 mile podle poctu valcu
cislo <- mtcars$qsec
valce <- as.factor(mtcars$cyl)
#Test normality residui linearniho modelu
lm_model <- lm(cislo~valce)
pred <- predict(lm_model) # predikce hodnot
res <- residuals(lm(cislo~valce))
res
"""
A residual is the difference between a predicted value of dependent variable y with the actual value of y.
"""
res_num = cislo - pred
par(mfrow=c(1,2))
PlotQQ(res)
PlotQQ(res_num)
par(mfrow=c(1,1))
# Ciselny test - normalně shapiro
#H0: residua maji normalni rozdeleni |H1: residua NEmaji normalni rozdeleni
tapply(cislo, valce,shapiro.test) #=> residua maji normali rozdeleni - p-value > alfa
# Ciselny test - normalně shapiro
#H0: residua maji normalni rozdeleni |H1: residua NEmaji normalni rozdeleni
tapply(cislo, valce,shapiro.test) #=> residua maji normali rozdeleni - p-value > alfa
boxplot(cislo~valce)
# Ciselny test - normalně shapiro
#H0: residua maji normalni rozdeleni |H1: residua NEmaji normalni rozdeleni
tapply(cislo, valce,shapiro.test) #=> residua maji normali rozdeleni - p-value > alfa
# Ciselny test - normalně shapiro
#H0: residua maji normalni rozdeleni |H1: residua NEmaji normalni rozdeleni
shapiro.test(res) #=> residua maji normali rozdeleni - p-value > alfa
var.test(cislo~valce) #=> jenom pro dva levely kategorické proměné
#Test shody rozptylu
# dle vysledku se voli typ ANOVy
# H0: rozptyly jsou shodne | H1: rozptyly se lisi
bartlett.test(cislo~valce) # => p-value = 0.4554 > alfa - maji shodne rozptyly
# Využití klasické anovy
anova(aov(cislo~valce))
# Muze prijit doplnujici otazka: ktere dvojice skupin se od sebe vyznamne lisi?
# Párové srovnání
tukey_result <- TukeyHSD(aov(cislo~valce))
plot(tukey_result)
## Zavisi pomer os na poctu prevodu?
cislo<-mtcars$drat
kategorie<-as.factor(mtcars$gear)
res <- residuals(lm(cislo~kategorie))
# Test normality residui
#H0: mají normální rozd.| H1: emají normální roz.
PlotQQ(res) # => spíše nemají
shapiro.test(res)
# Test shody rozptylu - i neparametricky test ocekava priblizne stejne rozptyly!
#H0: rozptyly se neliší | H1: rozptyly se liší
bartlett.test(cislo~kategorie)
kruskal.test(cislo~kategorie)
# Ktera dvojice skupin se od sebe vyznamne lisi?
DunnTest(cislo~kategorie)
boxplot(cislo~kategorie) #=> hodne se liší auta s 3 převody
# Analyza rozptylu pro pripad, ze se lisi variabilita ve skupinach
oneway.test(cislo~kategorie, var.equal = FALSE)
library(DescTools)
library(TeachingDemos)
data(mtcars)
## Souvisi spolu pocet valcu a typ prevodovky?
cyl <- mtcas$cyl
## Souvisi spolu pocet valcu a typ prevodovky?
cyl <- mtcars$cyl
trans <* mtcars$am
trans <- mtcars$am
levels(cyl)
## Souvisi spolu pocet valcu a typ prevodovky?
cyl <- as.factor(mtcars$cyl)
trans <- mtcars$am
levels(cyl)
## Souvisi spolu pocet valcu a typ prevodovky?
cyl <- as.factor(mtcars$cyl)
trans <- as.factor(mtcars$am)
levels(cyl)
levels(trans)
plot(cyl~trans)
chisq.test(cyl,trans)
## Souvisi spolu pocet valcu a typ prevodovky?
cyl <- mtcars$cyl
trans <- mtcars$am
chisq.test(cyl,trans)
plot(cyl~trans)
plot(as.factor(cyl)~as.factor(trans)
plot(as.factor(cyl)~as.factor(trans))
plot(as.factor(cyl)~as.factor(trans))
chisq.test(cyl,trans)
chisq.test(cyl,trans)$ex
#Fisheruv test
# => faktoriálový test -> vytvoří tabulku s pst pro jednotlivé varianty
fisher.test(cyl~tras)
#Fisheruv test
# => faktoriálový test -> vytvoří tabulku s pst pro jednotlivé varianty
fisher.test(cyl~trans)
#Fisheruv test
# => faktoriálový test -> vytvoří tabulku s pst pro jednotlivé varianty
fisher.test(cyl,trans)
## Souvisi spolu typ motoru a typ prevodovky (promenne vs a am)
motor <- mtcars$vs
trans #převodovka
plot(as.factor(motor), as.factor(trans))
plot(as.factor(motor), as.factor(trans))
mtcats
mtcars
chisq.test(motor,trans)
# => p-value = 0.5555 > alfa - > nenzámtíme H0
chisq.test(motor,trans)$ex
# Jiny vystup pro Fisheruv exaktni test
fisher.test(motor,trans)
read('./Stulong')
load("D:/PSM_TEACH/PSM_Teach/Stulong.RData")
names(Stulong)<-c("ID","vyska","vaha","syst1","syst2","chlst","vino","cukr",
"bmi","vek","KOURrisk","Skupina","VekK")
###################
### Vecna vyznamnost
library(effectsize)
library(DescTools)
install.packages("effectsize")
###################
### Vecna vyznamnost
library(effectsize)
library(DescTools)
## Je vyznamny rozdil ve vysce mezi starsimi a mladsimi muzi? (promenne vyska, VekK)
ciselna<-Stulong$vyska
kategoricka<-Stulong$VekK
tapply(ciselna,kategoricka,PlotQQ)
#Test normality
par(mfrow=c(1,2))
tapply(ciselna,kategoricka,PlotQQ)
par(mfrow=c(1,1))
par(mfrow=c(1,1))
tapply(ciselna,kategoricka,shapiro.test)
#F-test - var.test() - test shody rozptylu
var.test(cisla~kategoricka)
#F-test - var.test() - test shody rozptylu
var.test(ciselna~kategoricka)
# Shapiro
# H0: je normalni | H1: NENI normalni
tapply(ciselna,kategoricka,shapiro.test)
t.test(ciselna~kategoricka)
wilcox.test(ciselna~kategoricka)
### Statistiky vecne vyznamnosti
cohens_d(ciselna~kategoricka)
# Cohenovo d
interpret_cohens_d(cohens_d(ciselna~kategoricka))
# Glassovo delta
glass_delta(ciselna~kategoricka)
interpret_glass_delta(glass_delta(ciselna~kategoricka)
# Hedgesovo g
hedges_g(ciselna~kategoricka)
interpret_hedges_g(hedges_g(ciselna~kategoricka))
# Hedgesovo g
hedges_g(ciselna~kategoricka)
interpret_hedges_g(hedges_g(ciselna~kategoricka))
# Glassovo delta
glass_delta(ciselna~kategoricka)
interpret_glass_delta(glass_delta(ciselna~kategoricka)
interpret_glass_delta(glass_delta(ciselna~kategoricka)
# Glassovo delta
glass_delta(ciselna~kategoricka)
interpret_glass_delta(glass_delta(ciselna~kategoricka)
interpret_glass_delta(glass_delta(ciselna~kategoricka))
# Glassovo delta
glass_delta(ciselna~kategoricka)
interpret_glass_delta(glass_delta(ciselna~kategoricka))
interpret_glass_delta(glass_delta(ciselna~kategoricka))
# Glassovo delta
glass_delta(ciselna~kategoricka)
# Glassovo delta
glass_delta(ciselna~kategoricka)
interpret_glass_delta(glass_delta(ciselna~kategoricka))
### Pro ANOVA - ciselna x kategorická[>2]
eta_squared(aov(ciselna~kategoricka))
# Fisherovo eta
(A<-anova(aov(ciselna~kategoricka)))
### Pro ANOVA - ciselna x kategorická[>2]
eta_squared(aov(ciselna~kategoricka))
# Fisherovo eta
(A<-anova(aov(ciselna~kategoricka)))
A[,2]
A[1,2]/(sum(A[,2]))
omega_squared(aov(ciselna~kategoricka))
# Haysova omega
(A[1,2]-A[2,3])/(sum(A[,2])+A[2,3])
epsilon_squared(aov(ciselna~kategoricka))
# dalsi charakteristika
# dalsi charakteristika
# dalsi charakteristika
## Souvisi spolu diagnosticka Skupina a vek muzu (promenne Skupina, VekK)
kat1<-Stulong$Skupina
kat2<-Stulong$VekK
#Normalitu => rozptyl => test ChiKvadrát ->....
# Teď pomocí výnzmanosti řešíme JAK MOC spolu soluviší - jak velký je ten efekt..
tab <- tabůe(kat1,kat2)
#Normalitu => rozptyl => test ChiKvadrát ->....
# Teď pomocí výnzmanosti řešíme JAK MOC spolu soluviší - jak velký je ten efekt..
tab <- table(kat1,kat2)
tab
plot(as.factor(tab))
plot(as.factor(kat1),as.factor(kat2))
chisq.test(kat1,kat2)
chisq.test(kat1,kat2)
chisq_to_cramers_v(chisq.test(tab)$statistic,
n = sum(tab),
nrow = nrow(tab),
ncol = ncol(tab)
)
# Cramerovo V
sqrt(chisq.test(tab)$statistic/(sum(tab)*(ncol(tab)-1)))
chisq.test(tab)$statistic
n <-chisq.test(tab)
n
View(n)
# Cramerovo V - numericky
sqrt(chisq.test(tab)$statistic/(sum(tab)*(ncol(tab)-1)))
## Souvisi spolu konzumace vina a vek muzu (promenne vino, VekK)
vino<-Stulong$vino
vekK<-Stulong$VekK
chisq.test(vino,vekK)
cramer_v <- (chisq.test(vino,vekK)$statistic/length(vino)*(length(levels(vekK))))
cramer_v
tab2 <- table(vino,vekK)
sqrt(chisq.test(tab2)$statistic/(sum(tab2)*(ncol(tab2)-1)))
sum(tab2)
length(vekK)
length(vino)
# Numericky
cramer_v <- (chisq.test(vino,vekK)$statistic/length(vino)*(length(levels(vekK)-1)))
# Numericky
cramer_v <- (chisq.test(vino,vekK)$statistic/length(vino)*(length(levels(vekK))-1))
cramer_v
ncol(tab2)
levels(vekK)
length(levels(vekK))
sqrt(chisq.test(tab2)$statistic/(sum(tab2)*(ncol(tab2)-1)))
chisq.test(tab2)$statistic
chisq.test(vino,vekK)$statistic
length(vino)
(sum(tab2)
# Numericky
cramer_v <- (chisq.test(vino,vekK)$statistic/(length(vino)*(length(levels(vekK))-1)))
# Numericky
cramer_v <- (chisq.test(vino,vekK)$statistic/(length(vino)*(length(levels(vekK))-1)))
cramer_v
sqrt(chisq.test(tab2)$statistic/(sum(tab2)*(ncol(tab2)-1)))
(ncol(tab2)-1)
# Numericky
cramer_v <- sqrt(chisq.test(vino,vekK)$statistic/(length(vino)*(length(levels(vekK))-1)))
cramer_v
# Cramer V s tabulkou
tab2 <- table(vino,vekK)
# Funkce
chisq_to_cramers_v(chisq.test(tab2)$statistic,
n = sum(tab2),
nrow = nrow(tab2),
ncol = ncol(tab2)
)
cramer_v
_
# Funkce
chisq_to_cramers_v(chisq.test(tab2)$statistic,
n = sum(tab2),
nrow = nrow(tab2),
ncol = ncol(tab2)
)
## Souvisi spolu vaha a hladina cholesterolu?
cislo1<- Stulong$vaha
cislo2<-Stulong$chlst
## Souvisi spolu vaha a hladina cholesterolu?
#dvě kardiální proměnné (číselné), tak použiji korelační koeficient
cislo1<- Stulong$vaha
cislo2<-Stulong$chlst
plot(cislo1~cislo2,pch=19,main="Souvislost vahy a hladiny cholesterolu")
cor(cislo1,cislo2)
cor.test(cislo1,cislo2)
cor.test(cislo1,cislo2) # jak koef tak i p-value
# Zavislost je statisticky vyznamna
# H0: neí závilost |H1: je závislost
interpret_r(cor(cislo1,cislo2))
# Zavislost je statisticky vyznamna
# H0: neí závilost |H1: je závislost
interpret_r(cor(cislo1,cislo2)) # hodí i kategorii - small medium...
summary(lm(cislo1~cislo2))$r.squared
# koeficient determinace
# kolik procent variability zavisle promenne se modelem vysvetlilo
interpret_r2(summary(lm(cislo1~cislo2))$r.squared)
